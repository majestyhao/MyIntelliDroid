package fu.hao.intellidroid.core.wrappers;

import com.ibm.wala.classLoader.IField;
import com.ibm.wala.classLoader.IMethod;
import com.ibm.wala.ipa.callgraph.CGNode;
import com.ibm.wala.ipa.callgraph.propagation.PointerKey;
import com.ibm.wala.ipa.callgraph.propagation.SSAPropagationCallGraphBuilder;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ssa.SSAAbstractInvokeInstruction;
import com.ibm.wala.types.ClassLoaderReference;
import com.ibm.wala.types.TypeReference;
import fu.hao.intellidroid.core.IntelliDroidAppAnalysis;
import fu.hao.intellidroid.utils.Log;
import fu.hao.intellidroid.utils.Settings;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

/**
 * Description: Add ability to attach listener to call graph builder to get information about heap stores and invoked nodes.
 * Common utilities for CFA-style call graph builders.
 * This abstract base class provides the general algorithm for a call graph builder that relies on propagation through an iterative
 * dataflow solver, and constraints generated by statements in SSA form.
 * Authors: Hao Fu(haofu@ucdavis.edu)
 * Date: 2016/8/29
 */
public class CallGraphInfoListener implements SSAPropagationCallGraphBuilder.BuilderListener {
    private final String TAG = this.getClass().getSimpleName();

    private IClassHierarchy classHierarchy;
    private Map<String, Set<CGNode>> targetMethodInvokes = new HashMap<String, Set<CGNode>>();
    private Map<PointerKey, Set<CGNode>> heapStores = new HashMap<PointerKey, Set<CGNode>>();
    private Map<String, Set<CGNode>> sharedPrefStores = new HashMap<String, Set<CGNode>>();
    private Map<String, CGNode> sharedPrefUIStores = new HashMap<String, CGNode>();
    private Map<TypeReference, Set<CGNode>> callbackRegistrations = new HashMap<TypeReference, Set<CGNode>>();


    public CallGraphInfoListener(IClassHierarchy cha) {
        classHierarchy = cha;
    }

    @Override
    public void onPut(CGNode cgNode, IField iField, PointerKey[] pointerKeys) {
    }

    /**
     * Method: onInvoke
     * Description: When encounter a method invocation -- Visitor model
     * Authorsï¼šHao Fu(haofu@ucdavis.edu)
     * Date: 2016/9/1 20:17
     */
    @Override
    public void onInvoke(CGNode node, SSAAbstractInvokeInstruction invokeInstr) {
        // If it is not an app method
        if (!node.getMethod().getDeclaringClass().getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
            return;
        }

        // Get the invoked method
        IMethod targetMethod = classHierarchy.resolveMethod(invokeInstr.getDeclaredTarget());
        if (targetMethod == null) {
            return;
        }

        String targetMethodSignature = targetMethod.getSignature();
        Log.bb(TAG, targetMethodSignature);

        // If it is the sensitive target method
        if (Settings.getTargetMethods().contains(targetMethodSignature)) {
            if (!targetMethodInvokes.containsKey(targetMethodSignature)) {
                targetMethodInvokes.put(targetMethodSignature, new HashSet<CGNode>());
            }

            targetMethodInvokes.get(targetMethodSignature).add(node);
        }
        // TODO If it is a sharedPrefMethod
    }

    public void clear() {
        targetMethodInvokes.clear();
        heapStores.clear();
        sharedPrefStores.clear();
        sharedPrefUIStores.clear();
        callbackRegistrations.clear();
    }

    public Set<String> getTargetMethods() {
        return targetMethodInvokes.keySet();
    }

    public Set<CGNode> getTargetNodes(String method) {
        return targetMethodInvokes.get(method);
    }
}
